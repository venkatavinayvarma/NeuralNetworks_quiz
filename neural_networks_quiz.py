# -*- coding: utf-8 -*-
"""Neural_Networks_quiz.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hrLGV2QFKNVrPAK7OYKiPOyr6GXRWC9z

First Task of the Quiz
Time Series Forcasting Task.
"""

import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import LSTM, Dense

# Step 1: Load Time Series Data
data = pd.read_csv("/content/goldstock.csv")

# Step 2: Preprocess Data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(data['Close'].values.reshape(-1,1))

# Split data into training and testing sets
train_size = int(len(scaled_data) * 0.8)
test_size = len(scaled_data) - train_size
train_data, test_data = scaled_data[0:train_size,:], scaled_data[train_size:len(scaled_data),:]

# Function to create sequences
def create_sequences(data, seq_length):
    X, y = [], []
    for i in range(len(data)-seq_length):
        X.append(data[i:i+seq_length])
        y.append(data[i+seq_length])
    return np.array(X), np.array(y)

seq_length = 10
X_train, y_train = create_sequences(train_data, seq_length)
X_test, y_test = create_sequences(test_data, seq_length)

# Step 3: Build LSTM Model
model = Sequential()
model.add(LSTM(units=50, return_sequences=True, input_shape=(X_train.shape[1], X_train.shape[2])))
model.add(LSTM(units=50))
model.add(Dense(units=1))

# Step 4: Compile Model
model.compile(optimizer='adam', loss='mean_squared_error')

# Step 5: Train Model
model.fit(X_train, y_train, epochs=100, batch_size=32, verbose=2)

# Step 6: Evaluate Model
train_predict = model.predict(X_train)
test_predict = model.predict(X_test)

# Step 3: Build LSTM Model
model = Sequential()
model.add(LSTM(units=50, return_sequences=True, input_shape=(X_train.shape[1], X_train.shape[2])))
model.add(LSTM(units=50))
model.add(Dense(units=1))

# Step 4: Compile Model
model.compile(optimizer='adam', loss='mean_squared_error')

# Step 5: Train Model
model.fit(X_train, y_train, epochs=100, batch_size=32, verbose=2)

# Step 6: Evaluate Model
train_predict = model.predict(X_train)
test_predict = model.predict(X_test)

import matplotlib.pyplot as plt

# Select a specific range for visualization (e.g., test data)
plot_data_len = 100  # You can adjust this value

# Get predictions and ground truth for plotting
plot_predict = test_predict[:plot_data_len]
plot_y_test = y_test[:plot_data_len]

# Invert scaling for plotting
plot_predict = scaler.inverse_transform(plot_predict.reshape(-1, 1))
plot_y_test = scaler.inverse_transform(plot_y_test.reshape(-1, 1))

# Plot actual vs predicted values
plt.plot(plot_y_test, label='Actual Price')
plt.plot(plot_predict, label='Predicted Price')
plt.legend()
plt.xlabel('Time Step')
plt.ylabel('Gold Price')
plt.title('Actual vs Predicted Gold Prices')
plt.show()